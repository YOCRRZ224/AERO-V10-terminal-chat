import socket
import threading
import os
import sys
import time
import collections
import json

# --- Configuration ---
HOST = '127.0.0.1' # Change to '0.0.0.0' to allow connections from other devices on your network
PORT = 55555
BUFFER_SIZE = 1024 # Buffer size for receiving network data

# --- Admin Configuration ---
# The first user to connect from this IP address will automatically be made an admin.
# This status will then be persistent in their profile.
INITIAL_ADMIN_IP = '127.0.0.1' 

# --- Server-side Message History & MotD ---
MESSAGE_HISTORY_LIMIT = 20
message_history = collections.deque(maxlen=MESSAGE_HISTORY_LIMIT)
SERVER_MOTD = "Welcome to the Python Chat Server! Communicate securely and collaboratively."

# --- Persistence Configuration ---
USER_PROFILES_FILE = 'user_profiles.json' # File to store persistent user data
# --- Global User Profiles Data ---
# Structure: { "IP_address": { "nickname": "...", "color": "...", "todos": [], "is_admin": false } }
user_profiles = {} 

# --- Server Setup ---
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((HOST, PORT))
server.listen()

# --- Data Structures to Manage Clients and State (Live Session Data) ---
clients = []         # Stores active client socket objects
nicknames = {}       # Maps socket object -> nickname string (live session)
ip_addresses = {}    # Maps socket object -> (IP_address, Port) tuple (live session)
user_colors = {}     # Maps socket object -> color code (ANSI escape sequence) (live session)
user_statuses = {}   # Maps socket object -> status string (e.g., "online", "away") (live session)

dynamic_admin_nicknames = set() # Stores nicknames of users who are currently admins (live session)
initial_admin_assigned = False # Flag to ensure only one initial admin from INITIAL_ADMIN_IP
muted_nicknames = [] # Stores nicknames of muted users (live session)
banned_users = {}    # Maps banned nickname -> banned IP address (if known) (live session)

# --- File Transfer Management ---
# For Point-to-Point (P2P) transfers:
# { sender_socket: { 'recipient_socket': <socket_obj>, 'filename': <str>, 'file_size': <int>, 'bytes_received': <int>, 'start_time': <float> } }
active_p2p_file_transfers = {} 

# For Broadcast transfers:
# { sender_socket: { 'filename': <str>, 'file_size': <int>, 'bytes_received': <int>, 'start_time': <float>, 'recipients_sockets': set(<socket_obj>, ...) } }
active_broadcast_file_transfers = {}

# --- Work Topic Management ---
active_work_topics = set() # Stores unique names of active work topics

# --- ANSI Color Codes for Messages ---
COLOR_RESET = "\033[0m"
SERVER_INFO_COLOR = "\033[33m"  # Yellow for general server info/status (e.g., joins/leaves, file transfers)
SERVER_ANNOUNCE_COLOR = "\033[35m" # Magenta for formal announcements (e.g., /announce, /motd update)
WORK_TOPIC_COLOR = "\033[36m"   # Cyan for work topics
PM_COLOR = "\033[34m"           # Blue for private messages
TODO_COLOR = "\033[95m"         # Bright Magenta for to-do messages
ERROR_COLOR = "\033[31m"        # Red for error messages
SUCCESS_COLOR = "\033[32m"      # Green for success messages

# ANSI Color codes for user chosen colors
user_color_codes = {
    "black": "\033[30m", "red": "\033[31m", "green": "\033[32m", "yellow": "\033[33m",
    "blue": "\033[34m", "magenta": "\033[35m", "cyan": "\033[36m", "white": "\033[37m",
    "reset": "\033[0m", # Resets color to default (this is internal to the user's choice)
}


print(f"Server is listening on {HOST}:{PORT}...")

# --- Persistence Functions ---
def load_user_profiles():
    """Loads user profiles from a JSON file."""
    global user_profiles, initial_admin_assigned
    if os.path.exists(USER_PROFILES_FILE):
        try:
            with open(USER_PROFILES_FILE, 'r') as f:
                user_profiles = json.load(f)
            print(f"Loaded {len(user_profiles)} user profiles from {USER_PROFILES_FILE}")
            
            # Check if initial admin has already been set in a loaded profile
            for ip_addr, profile in user_profiles.items():
                if ip_addr == INITIAL_ADMIN_IP and profile.get('is_admin', False):
                    initial_admin_assigned = True
                    break
        except json.JSONDecodeError:
            print(f"Warning: Corrupted {USER_PROFILES_FILE}. Starting with empty profiles.")
            user_profiles = {}
        except Exception as e:
            print(f"Error loading user profiles: {e}")
            user_profiles = {}
    else:
        print(f"No {USER_PROFILES_FILE} found. Starting with empty profiles.")
        user_profiles = {}

def save_user_profiles():
    """Saves current user profiles to a JSON file."""
    try:
        with open(USER_PROFILES_FILE, 'w') as f:
            json.dump(user_profiles, f, indent=4)
        print(f"Saved {len(user_profiles)} user profiles to {USER_PROFILES_FILE}")
    except IOError as e:
        print(f"Error saving user profiles: {e}")

def get_user_profile(ip_addr):
    """Retrieves or creates a default user profile for a given IP address."""
    if ip_addr not in user_profiles:
        # Default profile for new IP
        user_profiles[ip_addr] = {
            'nickname': f"Guest_{len(user_profiles) + 1}", # Default guest nickname
            'color': user_color_codes['reset'], # Default color
            'todos': [], # Empty to-do list
            'is_admin': False
        }
        print(f"Created new profile for IP: {ip_addr}")
    return user_profiles[ip_addr]

# --- Helper Function: Send Message (Plain Text) ---
def send_message(client_socket, message_str):
    """Sends a plain string message as bytes to a specific client."""
    try:
        client_socket.send(message_str.encode('utf-8'))
    except Exception as e:
        # Error likely means client disconnected. Handle cleanup.
        print(f"Error sending to {nicknames.get(client_socket, 'Unknown')}: {e}")
        remove_client(client_socket)

# --- Helper Function: Broadcast Messages (Plain Text) ---
def broadcast(message_str, sender_socket=None, add_to_history=True):
    """
    Sends a plain string message to all connected clients.
    If add_to_history is True, the message is added to the server's history.
    """
    if add_to_history:
        message_history.append(message_str)
    
    for client_socket in clients:
        # Don't send to the sender if they're explicitly excluded (e.g., for self-echo prevention)
        if sender_socket and client_socket == sender_socket:
            continue
        send_message(client_socket, message_str)

# --- Helper Function: Remove Disconnected Clients ---
def remove_client(client_socket, reason="disconnected"):
    """Removes a client and cleans up their associated data and ongoing transfers."""
    if client_socket in clients:
        clients.remove(client_socket)
        
        nickname = nicknames.pop(client_socket, "Unknown")
        addr = ip_addresses.pop(client_socket, "Unknown")
        user_colors.pop(client_socket, None)
        user_statuses.pop(client_socket, None)
        dynamic_admin_nicknames.discard(nickname) # Remove from live admin list if they were one
        
        # --- Clean up any active file transfers associated with this client ---
        # (File transfer cleanup logic remains the same as before)
        
        # 1. If this client was a P2P sender:
        if client_socket in active_p2p_file_transfers:
            transfer = active_p2p_file_transfers.pop(client_socket)
            print(f"P2P Sender {nickname} ({addr}) disconnected mid-transfer of {transfer['filename']}")
            if transfer['recipient_socket'] in clients:
                send_message(transfer['recipient_socket'], f"{SERVER_INFO_COLOR}[SERVER]: P2P file transfer from {nickname} for '{transfer['filename']}' cancelled due to sender disconnection.{COLOR_RESET}")
        
        # 2. If this client was a P2P recipient:
        for sender_sock, transfer_info in list(active_p2p_file_transfers.items()):
            if transfer_info['recipient_socket'] == client_socket:
                print(f"P2P Recipient {nickname} ({addr}) disconnected mid-transfer of {transfer_info['filename']} from {nicknames.get(sender_sock, 'Unknown')}")
                send_message(sender_sock, f"{SERVER_INFO_COLOR}[SERVER]: P2P file transfer to {nickname} for '{transfer_info['filename']}' cancelled due to recipient disconnection.{COLOR_RESET}")
                del active_p2p_file_transfers[sender_sock] 

        # 3. If this client was a Broadcast sender:
        if client_socket in active_broadcast_file_transfers:
            broadcast_info = active_broadcast_file_transfers.pop(client_socket)
            print(f"Broadcast Sender {nickname} ({addr}) disconnected mid-broadcast of {broadcast_info['filename']}")
            for recipient_sock in list(broadcast_info['recipients_sockets']): 
                if recipient_sock in clients: 
                    send_message(recipient_sock, f"{SERVER_INFO_COLOR}[SERVER]: Broadcast file transfer from {nickname} for '{broadcast_info['filename']}' cancelled due to sender disconnection.{COLOR_RESET}")
        
        # 4. If this client was a Broadcast recipient:
        for sender_sock, broadcast_info in list(active_broadcast_file_transfers.items()):
            if client_socket in broadcast_info['recipients_sockets']:
                print(f"Broadcast Recipient {nickname} ({addr}) disconnected mid-broadcast of {broadcast_info['filename']} from {nicknames.get(sender_sock, 'Unknown')}")
                broadcast_info['recipients_sockets'].discard(client_socket)

        try:
            client_socket.close() # Close the socket
        except Exception as e:
            print(f"Error closing socket for {nickname}: {e}")

        print(f"Client '{nickname}' ({addr}) {reason}.")
        broadcast(f"{SERVER_INFO_COLOR}[SERVER]: {nickname} has {reason}.{COLOR_RESET}") # Inform other clients about the disconnection

# --- To-Do List Management on Server ---
def get_next_todo_id(todos_list):
    """Calculates the next available ID for a to-do item."""
    return max([todo['id'] for todo in todos_list]) + 1 if todos_list else 1

def handle_add_todo(profile, task_description):
    """Adds a to-do item to a user's profile."""
    next_id = get_next_todo_id(profile['todos'])
    profile['todos'].append({'id': next_id, 'task': task_description, 'completed': False})
    save_user_profiles()
    return f"{TODO_COLOR}[TO-DO]: Added task {next_id}: '{task_description}'{COLOR_RESET}"

def handle_list_todos(profile, filter_type='all'):
    """Lists to-do items from a user's profile."""
    todos = profile['todos']
    if not todos:
        return f"{TODO_COLOR}[TO-DO]: Your to-do list is empty.{COLOR_RESET}"

    response = f"{TODO_COLOR}--- Your To-Do List ---\n{COLOR_RESET}"
    found_tasks = False
    for todo in todos:
        status_symbol = "‚úÖ" if todo['completed'] else "‚ùå"
        if (filter_type == 'all' or
            (filter_type == 'pending' and not todo['completed']) or
            (filter_type == 'completed' and todo['completed'])):
            response += f"{TODO_COLOR}[{todo['id']}] {status_symbol} {todo['task']}\n{COLOR_RESET}"
            found_tasks = True
    
    if not found_tasks:
        response += f"{TODO_COLOR}No {filter_type} tasks found.\n{COLOR_RESET}"

    response += f"{TODO_COLOR}-----------------------{COLOR_RESET}\n"
    return response

def handle_complete_todo(profile, task_id):
    """Marks a to-do item as complete in a user's profile."""
    try:
        task_id = int(task_id)
        for todo in profile['todos']:
            if todo['id'] == task_id:
                todo['completed'] = True
                save_user_profiles()
                return f"{TODO_COLOR}[TO-DO]: Task {task_id} marked as complete. ‚úÖ{COLOR_RESET}"
        return f"{ERROR_COLOR}[TO-DO]: Task {task_id} not found.{COLOR_RESET}"
    except ValueError:
        return f"{ERROR_COLOR}[TO-DO]: Invalid task ID. Please provide a number.{COLOR_RESET}"

def handle_remove_todo(profile, task_id):
    """Removes a to-do item from a user's profile."""
    try:
        task_id = int(task_id)
        original_len = len(profile['todos'])
        profile['todos'] = [todo for todo in profile['todos'] if todo['id'] != task_id]
        if len(profile['todos']) < original_len:
            save_user_profiles()
            return f"{TODO_COLOR}[TO-DO]: Task {task_id} removed.{COLOR_RESET}"
        else:
            return f"{ERROR_COLOR}[TO-DO]: Task {task_id} not found.{COLOR_RESET}"
    except ValueError:
        return f"{ERROR_COLOR}[TO-DO]: Invalid task ID. Please provide a number.{COLOR_RESET}"

def handle_todo_help():
    """Returns the help message for to-do commands."""
    return (
        f"{TODO_COLOR}--- To-Do List Commands ---\n"
        f"/todo add <task_description> - Add a new task.\n"
        f"/todo list [all|pending|completed] - List tasks. Default is 'all'.\n"
        f"/todo complete <task_id> - Mark a task as complete.\n"
        f"/todo remove <task_id> - Remove a task.\n"
        f"/todo help - Show this help message.\n"
        f"---------------------------\n{COLOR_RESET}"
    )

# --- Help Command Logic ---
def get_help_message(is_admin):
    """Returns a formatted help message, customized for admin status."""
    help_msg = f"{SERVER_INFO_COLOR}--- Available Commands ---\n" \
               f"/help - Show this help message.\n" \
               f"/users - List all connected users and their status.\n" \
               f"/pm <nickname> <message> - Send a private message to a user.\n" \
               f"/away [message] - Set your status to away (optional message).\n" \
               f"/back - Set your status back to online.\n" \
               f"/history - View recent chat history.\n" \
               f"/color <color> - Change your nickname color (e.g., red, blue).\n" \
               f"/todo help - Show commands for your personal to-do list.\n" \
               f"/sendfile <recipient_nick> <path_to_file> - Send a file to one user.\n" \
               f"/sendallfile <path_to_file> - Broadcast a file to all users.\n" \
               f"/big <text> - Convert text to ASCII art.\n" \
               f"/newwork <topic_name> - Start a new work topic.\n" \
               f"/work <topic_name> <message> - Send a message tagged to a work topic.\n" \
               f"/works - List all active work topics.\n"
    
    if is_admin:
        help_msg += f"\n--- Admin Commands (You are an Admin) ---\n" \
                    f"/addadmin <nickname> - Promote a user to admin status.\n" \
                    f"/kick <nickname> - Disconnect a user from the server.\n" \
                    f"/ban <nickname> - Ban a user (by their IP) from the server.\n" \
                    f"/mute <nickname> - Prevent a user from sending messages.\n" \
                    f"/unmute <nickname> - Allow a muted user to send messages.\n" \
                    f"/announce <message> - Send a server-wide announcement.\n" \
                    f"/motd [new_message] - View or update the Message of the Day.\n" \
                    f"/shutdown - Shut down the server gracefully.\n"
    
    help_msg += f"--------------------------{COLOR_RESET}"
    return help_msg

# --- Handle Individual Client Connections ---
def handle_client(client_socket):
    """Handles messages and file data from a connected client."""
    nickname = nicknames[client_socket]
    client_ip = ip_addresses[client_socket][0] # Get the client's IP
    
    try:
        while True:
            # --- Handle incoming File Data Chunks ---
            is_p2p_sender = client_socket in active_p2p_file_transfers
            is_broadcast_sender = client_socket in active_broadcast_file_transfers

            if is_p2p_sender or is_broadcast_sender:
                if is_p2p_sender:
                    transfer_info = active_p2p_file_transfers[client_socket]
                    recipient_socket = transfer_info['recipient_socket']
                    file_size = transfer_info['file_size']
                    bytes_received_from_sender = transfer_info['bytes_received']
                    target_sockets_to_relay = [recipient_socket] 
                    transfer_type = "P2P"
                else: # is_broadcast_sender
                    transfer_info = active_broadcast_file_transfers[client_socket]
                    file_size = transfer_info['file_size']
                    bytes_received_from_sender = transfer_info['bytes_received']
                    target_sockets_to_relay = list(transfer_info['recipients_sockets'])
                    transfer_type = "Broadcast"

                remaining_bytes_from_sender = file_size - bytes_received_from_sender
                bytes_to_read = min(BUFFER_SIZE, remaining_bytes_from_sender)
                
                if bytes_to_read <= 0:
                    pass 
                else:
                    file_data_chunk = client_socket.recv(bytes_to_read)
                    
                    if not file_data_chunk:
                        print(f"Sender {nickname} disconnected during {transfer_type} file data transfer.")
                        break 

                    for target_sock in list(target_sockets_to_relay): 
                        if target_sock in clients: 
                            try:
                                target_sock.sendall(file_data_chunk)
                            except Exception as e:
                                print(f"Error relaying {transfer_type} file data from {nickname} to {nicknames.get(target_sock, 'Unknown')}: {e}")
                                if is_broadcast_sender:
                                    transfer_info['recipients_sockets'].discard(target_sock)
                                elif is_p2p_sender:
                                    send_message(client_socket, f"{ERROR_COLOR}[SERVER]: Error relaying file to {nicknames.get(target_sock, 'Unknown')}. Transfer cancelled.{COLOR_RESET}")
                                    send_message(target_sock, f"{SERVER_INFO_COLOR}[SERVER]: P2P file transfer from {nickname} for '{transfer_info['filename']}' cancelled due to relay error.{COLOR_RESET}")
                                    del active_p2p_file_transfers[client_socket]
                                    break
                        else:
                            if is_broadcast_sender:
                                transfer_info['recipients_sockets'].discard(client_socket) # No longer send to this disconnected recipient
                            elif is_p2p_sender:
                                print(f"P2P Recipient disconnected during file transfer from {nickname}.")
                                send_message(client_socket, f"{ERROR_COLOR}[SERVER]: File transfer to {nicknames.get(target_sock, 'Unknown')} cancelled: Recipient disconnected.{COLOR_RESET}")
                                del active_p2p_file_transfers[client_socket]
                                break

                    transfer_info['bytes_received'] += len(file_data_chunk)
                    continue 

            # --- Handle Regular Chat Messages and Commands ---
            message_bytes = client_socket.recv(BUFFER_SIZE)
            
            if not message_bytes:
                break # Client disconnected

            decoded_message = message_bytes.decode('utf-8').strip()

            is_admin = nickname in dynamic_admin_nicknames

            # --- Check if user is muted ---
            if nickname in muted_nicknames and not decoded_message.startswith('/unmute'):
                send_message(client_socket, f"{ERROR_COLOR}You are muted and cannot send messages.{COLOR_RESET}")
                continue

            # --- Handle Commands ---
            if decoded_message.startswith('/'):
                parts = decoded_message.split(' ', 2)
                command = parts[0]
                arg1 = parts[1] if len(parts) > 1 else None
                arg2 = parts[2] if len(parts) > 2 else None

                # --- NEW/MODIFIED: Work Topic Commands ---
                if command == '/newwork':
                    if arg1:
                        work_name = arg1
                        if work_name in active_work_topics:
                            send_message(client_socket, f"{ERROR_COLOR}Work topic '{work_name}' already exists.{COLOR_RESET}")
                        else:
                            active_work_topics.add(work_name)
                            broadcast(f"{SERVER_INFO_COLOR}[SERVER]: New work topic '{work_name}' has been started by {nickname}!{COLOR_RESET}")
                            send_message(client_socket, f"{SUCCESS_COLOR}Work topic '{work_name}' created successfully.{COLOR_RESET}")
                    else:
                        send_message(client_socket, f"{ERROR_COLOR}Usage: /newwork <topic_name>{COLOR_RESET}")
                
                elif command == '/works':
                    if active_work_topics:
                        work_list = f"{SERVER_INFO_COLOR}--- Active Work Topics ---{COLOR_RESET}"
                        for topic in sorted(list(active_work_topics)): 
                            work_list += f"\n{SERVER_INFO_COLOR}- {topic}{COLOR_RESET}"
                        work_list += f"\n{SERVER_INFO_COLOR}--------------------------{COLOR_RESET}"
                        send_message(client_socket, work_list)
                    else:
                        send_message(client_socket, f"{SERVER_INFO_COLOR}No active work topics found. Use /newwork <topic_name> to create one.{COLOR_RESET}")
                
                elif command == '/work':
                    if arg1 and arg2: 
                        work_name = arg1
                        work_message = arg2
                        color_code = user_colors.get(client_socket, "")
                        full_message = f"{WORK_TOPIC_COLOR}[WORK: {work_name}] {color_code}{nickname}: {work_message}{COLOR_RESET}"
                        broadcast(full_message, sender_socket=client_socket)
                    else:
                        send_message(client_socket, f"{ERROR_COLOR}Usage: /work <topic_name> <message>{COLOR_RESET}")

                # --- MODIFIED: To-Do List Commands (SERVER-SIDE PROCESSING) ---
                elif command == '/todo':
                    profile = user_profiles[client_ip] # Get the user's profile
                    if arg1 == 'add':
                        if arg2: # arg2 is task description
                            response = handle_add_todo(profile, arg2)
                        else:
                            response = f"{ERROR_COLOR}Usage: /todo add <task_description>{COLOR_RESET}"
                    elif arg1 == 'list':
                        response = handle_list_todos(profile, arg2 if arg2 in ['all', 'pending', 'completed'] else 'all')
                    elif arg1 == 'complete':
                        if arg2: # arg2 is task_id
                            response = handle_complete_todo(profile, arg2)
                        else:
                            response = f"{ERROR_COLOR}Usage: /todo complete <task_id>{COLOR_RESET}"
                    elif arg1 == 'remove':
                        if arg2: # arg2 is task_id
                            response = handle_remove_todo(profile, arg2)
                        else:
                            response = f"{ERROR_COLOR}Usage: /todo remove <task_id>{COLOR_RESET}"
                    elif arg1 == 'help':
                        response = handle_todo_help()
                    else:
                        response = f"{ERROR_COLOR}Unknown to-do command. Use /todo help for options.{COLOR_RESET}"
                    send_message(client_socket, response) # Send response back to client

                # --- File Transfer Initiation (via /sendfile command) ---
                elif command == '/sendfile':
                    if len(parts) < 3: 
                        send_message(client_socket, f"{ERROR_COLOR}Usage: /sendfile <recipient_nickname> <filename>|<file_size>{COLOR_RESET}")
                        continue
                    
                    recipient_nickname = arg1
                    file_info = parts[2].split('|') 
                    if len(file_info) != 2:
                        send_message(client_socket, f"{ERROR_COLOR}Invalid file info format. Use <filename>|<file_size>.{COLOR_RESET}")
                        continue
                    
                    filename_to_transfer = file_info[0]
                    try:
                        file_size_to_transfer = int(file_info[1])
                    except ValueError:
                        send_message(client_socket, f"{ERROR_COLOR}Invalid file size. Must be a number.{COLOR_RESET}")
                        continue

                    if not (1 <= len(filename_to_transfer) <= 255) or file_size_to_transfer <= 0:
                        send_message(client_socket, f"{ERROR_COLOR}Invalid filename/size.{COLOR_RESET}")
                        continue

                    recipient_socket = None
                    for sock, name in nicknames.items():
                        if name == recipient_nickname:
                            recipient_socket = sock
                            break

                    if not recipient_socket:
                        send_message(client_socket, f"{ERROR_COLOR}Error: Recipient '{recipient_nickname}' not found or not online.{COLOR_RESET}")
                        continue
                    
                    if client_socket in active_p2p_file_transfers or client_socket in active_broadcast_file_transfers:
                        send_message(client_socket, f"{ERROR_COLOR}You are already sending a file. Please wait or cancel the current transfer.{COLOR_RESET}")
                        continue

                    active_p2p_file_transfers[client_socket] = {
                        'recipient_socket': recipient_socket,
                        'filename': filename_to_transfer, 'file_size': file_size_to_transfer,
                        'bytes_received': 0, 'start_time': time.time()
                    }
                    print(f"P2P file transfer initiated from {nickname} to {recipient_nickname}: '{filename_to_transfer}' ({file_size_to_transfer} bytes)")

                    send_message(recipient_socket, f"{SERVER_INFO_COLOR}FILE_TRANSFER_START|{nickname}|{filename_to_transfer}|{file_size_to_transfer}{COLOR_RESET}")
                    send_message(client_socket, f"{SERVER_INFO_COLOR}FILE_READY_TO_SEND {filename_to_transfer}{COLOR_RESET}")
                    continue 

                # --- Broadcast File Transfer Initiation (via /sendallfile command) ---
                elif command == '/sendallfile':
                    if len(parts) < 2: 
                        send_message(client_socket, f"{ERROR_COLOR}Usage: /sendallfile <filename>|<file_size>{COLOR_RESET}")
                        continue
                    
                    file_info = arg1.split('|') 
                    if len(file_info) != 2:
                        send_message(client_socket, f"{ERROR_COLOR}Invalid file info format. Use <filename>|<file_size>.{COLOR_RESET}")
                        continue
                    
                    filename_to_transfer = file_info[0]
                    try:
                        file_size_to_transfer = int(file_info[1])
                    except ValueError:
                        send_message(client_socket, f"{ERROR_COLOR}Invalid file size. Must be a number.{COLOR_RESET}")
                        continue

                    if not (1 <= len(filename_to_transfer) <= 255) or file_size_to_transfer <= 0:
                        send_message(client_socket, f"{ERROR_COLOR}Invalid filename/size.{COLOR_RESET}")
                        continue

                    if client_socket in active_p2p_file_transfers or client_socket in active_broadcast_file_transfers:
                        send_message(client_socket, f"{ERROR_COLOR}You are already sending a file. Please wait or cancel the current transfer.{COLOR_RESET}")
                        continue
                    
                    recipients_sockets = set(c for c in clients if c != client_socket)
                    if not recipients_sockets:
                        send_message(client_socket, f"{SERVER_INFO_COLOR}No other users online to broadcast the file to.{COLOR_RESET}")
                        continue

                    active_broadcast_file_transfers[client_socket] = {
                        'filename': filename_to_transfer, 'file_size': file_size_to_transfer,
                        'bytes_received': 0, 'start_time': time.time(),
                        'recipients_sockets': recipients_sockets 
                    }
                    print(f"Broadcast file transfer initiated from {nickname}: '{filename_to_transfer}' ({file_size_to_transfer} bytes) to {len(recipients_sockets)} users.")

                    for r_sock in recipients_sockets:
                        send_message(r_sock, f"{SERVER_INFO_COLOR}FILE_TRANSFER_START|{nickname}|{filename_to_transfer}|{file_size_to_transfer}{COLOR_RESET}")
                    
                    send_message(client_socket, f"{SERVER_INFO_COLOR}FILE_READY_TO_SEND {filename_to_transfer}{COLOR_RESET}")
                    continue 

                # --- File Transfer Completion (from client) ---
                elif command == '/FILE_COMPLETE': 
                    filename_completed = arg1
                    
                    if client_socket in active_p2p_file_transfers:
                        transfer_info = active_p2p_file_transfers.pop(client_socket)
                        recipient_socket = transfer_info['recipient_socket']
                        if recipient_socket in clients: 
                            send_message(recipient_socket, f"{SERVER_INFO_COLOR}[FILE TRANSFER]: File '{filename_completed}' from {nickname} completed successfully!{COLOR_RESET}")
                        send_message(client_socket, f"{SUCCESS_COLOR}File '{filename_completed}' sent successfully to {nicknames.get(recipient_socket, 'Unknown')}.{COLOR_RESET}")
                        print(f"P2P file transfer from {nickname} for '{filename_completed}' completed.")
                    
                    elif client_socket in active_broadcast_file_transfers:
                        broadcast_info = active_broadcast_file_transfers.pop(client_socket)
                        for r_sock in list(broadcast_info['recipients_sockets']): 
                            if r_sock in clients: 
                                send_message(r_sock, f"{SERVER_INFO_COLOR}[FILE TRANSFER]: Broadcast file '{filename_completed}' from {nickname} completed successfully!{COLOR_RESET}")
                        send_message(client_socket, f"{SUCCESS_COLOR}Broadcast file '{filename_completed}' sent successfully to {len(broadcast_info['recipients_sockets'])} users.{COLOR_RESET}")
                        print(f"Broadcast file transfer from {nickname} for '{filename_completed}' completed.")
                    else:
                        send_message(client_socket, f"{ERROR_COLOR}Unexpected file completion signal for '{filename_completed}'. No active transfer found.{COLOR_RESET}")
                    continue 

                # --- MODIFIED: /color Command ---
                elif command == '/color':
                    if arg1 and arg1.lower() in user_color_codes:
                        user_colors[client_socket] = user_color_codes[arg1.lower()]
                        # Persist the color change in the user's profile
                        user_profiles[client_ip]['color'] = user_color_codes[arg1.lower()]
                        save_user_profiles()
                        send_message(client_socket, f"{SUCCESS_COLOR}Your nickname color is now {arg1.lower()}.{COLOR_RESET}")
                    else:
                        send_message(client_socket, f"{ERROR_COLOR}Usage: /color <color>\nAvailable colors: {', '.join(user_color_codes.keys())}{COLOR_RESET}")
                
                # --- MODIFIED: /users Command ---
                elif command == '/users':
                    user_list = f"{SERVER_INFO_COLOR}--- Connected Users ({len(clients)}) ---\n{COLOR_RESET}"
                    if nicknames:
                        for sock, name in nicknames.items():
                            status = user_statuses.get(sock, "online")
                            color = user_colors.get(sock, "")
                            
                            is_admin_user = name in dynamic_admin_nicknames
                            
                            status_symbol = "‚úÖ" # online
                            status_text = "online"

                            if status.startswith("away"):
                                status_symbol = "üåô" # away
                                status_text = status # "away" or "away: message"
                            
                            display_name = f"{color}{name}{COLOR_RESET}"
                            
                            if is_admin_user:
                                user_list += f"{SERVER_INFO_COLOR}‚≠ê {display_name} (Admin"
                                if status.startswith("away"):
                                    user_list += f", {status_text}"
                                user_list += f"){COLOR_RESET}\n"
                            else:
                                user_list += f"{SERVER_INFO_COLOR}{status_symbol} {display_name} ({status_text}){COLOR_RESET}\n"
                    else:
                        user_list += f"{SERVER_INFO_COLOR}No users connected.\n{COLOR_RESET}"
                    user_list += f"{SERVER_INFO_COLOR}-----------------------\n{COLOR_RESET}"
                    send_message(client_socket, user_list)
                
                elif command == '/pm':
                    if arg1 and arg2: 
                        target_nickname = arg1
                        private_msg_content = arg2
                        
                        target_socket = None
                        for sock, name in nicknames.items():
                            if name == target_nickname:
                                target_socket = sock
                                break
                        
                        if target_socket:
                            try:
                                send_message(target_socket, f"{PM_COLOR}[PM from {nickname}]: {private_msg_content}{COLOR_RESET}")
                                send_message(client_socket, f"{PM_COLOR}[PM to {target_nickname}]: {private_msg_content}{COLOR_RESET}")
                            except Exception as e:
                                send_message(client_socket, f"{ERROR_COLOR}Error sending PM: {target_nickname} could not be reached. ({e}){COLOR_RESET}")
                                remove_client(target_socket) 
                        else:
                            send_message(client_socket, f"{ERROR_COLOR}Error: User '{target_nickname}' not found.{COLOR_RESET}")
                    else:
                        send_message(client_socket, f"{ERROR_COLOR}Usage: /pm <target_nickname> <message>{COLOR_RESET}")
                
                elif command == '/away':
                    status_message = decoded_message[len('/away'):].strip() 
                    if status_message:
                        user_statuses[client_socket] = f"away: {status_message}"
                        broadcast(f"{SERVER_INFO_COLOR}{nickname} is now away: {status_message}{COLOR_RESET}")
                    else:
                        user_statuses[client_socket] = "away"
                        broadcast(f"{SERVER_INFO_COLOR}{nickname} is now away.{COLOR_RESET}")
                    send_message(client_socket, f"{SUCCESS_COLOR}You are now {user_statuses[client_socket]}.{COLOR_RESET}")

                elif command == '/back':
                    user_statuses[client_socket] = "online"
                    broadcast(f"{SERVER_INFO_COLOR}{nickname} is back online.{COLOR_RESET}")
                    send_message(client_socket, f"{SUCCESS_COLOR}You are back online.{COLOR_RESET}")
                
                elif command == '/history':
                    if message_history:
                        send_message(client_socket, f"{SERVER_INFO_COLOR}\n--- Recent Chat History ---{COLOR_RESET}")
                        for hist_msg_str in message_history:
                            send_message(client_socket, hist_msg_str)
                        send_message(client_socket, f"{SERVER_INFO_COLOR}--- End of History ---\n{COLOR_RESET}")
                    else:
                        send_message(client_socket, f"{SERVER_INFO_COLOR}No chat history available yet.{COLOR_RESET}")
                
                # --- NEW: /help Command ---
                elif command == '/help':
                    send_message(client_socket, get_help_message(is_admin))

                # --- Admin Commands (requires is_admin check) ---
                elif is_admin:
                    # MODIFIED: /addadmin Command
                    if command == '/addadmin':
                        if arg1:
                            target_nickname = arg1
                            target_socket = None
                            for sock, name in nicknames.items():
                                if name == target_nickname:
                                    target_socket = sock
                                    break
                            
                            if target_nickname in nicknames.values(): # User is connected
                                if target_nickname in dynamic_admin_nicknames:
                                    send_message(client_socket, f"{ERROR_COLOR}'{target_nickname}' is already an admin.{COLOR_RESET}")
                                else:
                                    # Update live admin list
                                    dynamic_admin_nicknames.add(target_nickname)
                                    # Persist in user's profile based on their IP
                                    target_ip = ip_addresses[target_socket][0]
                                    user_profiles[target_ip]['is_admin'] = True
                                    save_user_profiles()

                                    send_message(client_socket, f"{SUCCESS_COLOR}'{target_nickname}' has been added as an admin.{COLOR_RESET}")
                                    broadcast(f"{SERVER_ANNOUNCE_COLOR}[SERVER]: {target_nickname} has been promoted to administrator!{COLOR_RESET}")
                                    send_message(target_socket, f"{SERVER_ANNOUNCE_COLOR}You have been promoted to administrator!{COLOR_RESET}")
                            else: # User not connected, still set admin status for their IP if known
                                found_in_profiles = False
                                for ip, profile in user_profiles.items():
                                    if profile['nickname'] == target_nickname:
                                        profile['is_admin'] = True
                                        save_user_profiles()
                                        send_message(client_socket, f"{SUCCESS_COLOR}Admin status for '{target_nickname}' (IP: {ip}) will apply on next connection.{COLOR_RESET}")
                                        found_in_profiles = True
                                        break
                                if not found_in_profiles:
                                    send_message(client_socket, f"{ERROR_COLOR}Error: User '{target_nickname}' not found in connected users or saved profiles.{COLOR_RESET}")
                        else:
                            send_message(client_socket, f"{ERROR_COLOR}Usage: /addadmin <nickname>{COLOR_RESET}")

                    elif command == '/kick':
                        if arg1:
                            target_nickname = arg1
                            target_socket = None
                            for sock, name in nicknames.items():
                                if name == target_nickname:
                                    target_socket = sock
                                    break
                            
                            if target_socket and target_nickname != nickname and target_nickname not in dynamic_admin_nicknames:
                                send_message(target_socket, f"{ERROR_COLOR}You have been kicked from the server!{COLOR_RESET}")
                                remove_client(target_socket, reason="kicked") 
                                send_message(client_socket, f"{SUCCESS_COLOR}'{target_nickname}' has been kicked.{COLOR_RESET}")
                            elif target_nickname == nickname:
                                send_message(client_socket, f"{ERROR_COLOR}You cannot kick yourself.{COLOR_RESET}")
                            elif target_nickname in dynamic_admin_nicknames:
                                send_message(client_socket, f"{ERROR_COLOR}Cannot kick admin '{target_nickname}'.{COLOR_RESET}")
                            else:
                                send_message(client_socket, f"{ERROR_COLOR}User '{target_nickname}' not found.{COLOR_RESET}")
                        else:
            
                            send_message(client_socket, f"{ERROR_COLOR}Usage: /kick <nickname>{COLOR_RESET}")

                    elif command == '/ban':
                        if arg1:
                            target_nickname = arg1
                            target_socket = None
                            target_ip = None
                            for sock, name in nicknames.items():
                                if name == target_nickname:
                                    target_socket = sock
                                    target_ip = ip_addresses[sock][0] 
                                    break
                            
                            if target_nickname == nickname:
                                send_message(client_socket, f"{ERROR_COLOR}You cannot ban yourself.{COLOR_RESET}")
                            elif target_nickname in dynamic_admin_nicknames:
                                send_message(client_socket, f"{ERROR_COLOR}Cannot ban admin '{target_nickname}'.{COLOR_RESET}")
                            else:
                                # Add to live banned list (by nickname for immediate effect if connected)
                                banned_users[target_nickname] = target_ip if target_ip else "unknown" 
                                # Persist ban in user's profile (by IP for future connections)
                                if target_ip and target_ip in user_profiles:
                                    user_profiles[target_ip]['banned'] = True 
                                    save_user_profiles()

                                if target_socket:
                                    send_message(target_socket, f"{ERROR_COLOR}You have been banned from the server!{COLOR_RESET}")
                                    remove_client(target_socket, reason="banned") 
                                send_message(client_socket, f"{SUCCESS_COLOR}'{target_nickname}' ({target_ip if target_ip else 'not connected'}) has been banned.{COLOR_RESET}")
                                broadcast(f"{SERVER_ANNOUNCE_COLOR}[SERVER]: {target_nickname} has been banned.{COLOR_RESET}")
                        else:
                            send_message(client_socket, f"{ERROR_COLOR}Usage: /ban <nickname>{COLOR_RESET}")
                    
                    elif command == '/mute':
                        if arg1:
                            target_nickname = arg1
                            if target_nickname not in nicknames.values():
                                send_message(client_socket, f"{ERROR_COLOR}User '{target_nickname}' not found.{COLOR_RESET}")
                            elif target_nickname in dynamic_admin_nicknames:
                                send_message(client_socket, f"{ERROR_COLOR}Cannot mute admin '{target_nickname}'.{COLOR_RESET}")
                            elif target_nickname in muted_nicknames:
                                send_message(client_socket, f"{ERROR_COLOR}User '{target_nickname}' is already muted.{COLOR_RESET}")
                            else:
                                muted_nicknames.append(target_nickname)
                                send_message(client_socket, f"{SUCCESS_COLOR}User '{target_nickname}' has been muted.{COLOR_RESET}")
                                broadcast(f"{SERVER_ANNOUNCE_COLOR}[SERVER]: {target_nickname} has been muted.{COLOR_RESET}")
                        else:
                            send_message(client_socket, f"{ERROR_COLOR}Usage: /mute <nickname>{COLOR_RESET}")
                    
                    elif command == '/unmute':
                        if arg1:
                            target_nickname = arg1
                            if target_nickname in muted_nicknames:
                                muted_nicknames.remove(target_nickname)
                                send_message(client_socket, f"{SUCCESS_COLOR}User '{target_nickname}' has been unmuted.{COLOR_RESET}")
                                broadcast(f"{SERVER_ANNOUNCE_COLOR}[SERVER]: {target_nickname} has been unmuted.{COLOR_RESET}")
                            else:
                                send_message(client_socket, f"{ERROR_COLOR}User '{target_nickname}' is not muted.{COLOR_RESET}")
                        else:
                            send_message(client_socket, f"{ERROR_COLOR}Usage: /unmute <nickname>{COLOR_RESET}")

                    elif command == '/announce':
                        if arg1: 
                            announcement = f"{SERVER_ANNOUNCE_COLOR}[SERVER ANNOUNCEMENT by {nickname}]: {arg1}{COLOR_RESET}"
                            broadcast(announcement)
                        else:
                            send_message(client_socket, f"{ERROR_COLOR}Usage: /announce <message>{COLOR_RESET}")
                    
                    elif command == '/motd':
                        global SERVER_MOTD
                        if arg1: 
                            SERVER_MOTD = arg1
                            send_message(client_socket, f"{SUCCESS_COLOR}Server Motd updated to: {SERVER_MOTD}{COLOR_RESET}")
                            broadcast(f"{SERVER_ANNOUNCE_COLOR}[SERVER]: Message of the Day has been updated.{COLOR_RESET}")
                        else:
                            send_message(client_socket, f"{SERVER_INFO_COLOR}Current Motd: {SERVER_MOTD}\nUsage: /motd <new_message>{COLOR_RESET}")

                    elif command == '/shutdown':
                        send_message(client_socket, f"{SERVER_ANNOUNCE_COLOR}Server is shutting down... Goodbye!{COLOR_RESET}")
                        print("Admin requested server shutdown.")
                        broadcast(f"{SERVER_ANNOUNCE_COLOR}[SERVER]: Server is shutting down now!{COLOR_RESET}")
                        time.sleep(1) # Give clients a moment to receive shutdown message
                        global server_running
                        server_running = False 
                        
                    else:
                        send_message(client_socket, f"{ERROR_COLOR}Unknown admin command.{COLOR_RESET}")

                else: # Command not found or user not authorized
                    send_message(client_socket, f"{ERROR_COLOR}Unknown command or you do not have permission to use this command.{COLOR_RESET}")
                
            # --- Handle Regular Chat Messages ---
            else:
                color_code = user_colors.get(client_socket, "") 
                full_message = f"{color_code}{nickname}: {decoded_message}{COLOR_RESET}" 
                broadcast(full_message, sender_socket=client_socket) 

    except ConnectionResetError:
        print(f"Client '{nickname}' disconnected unexpectedly.")
    except Exception as e:
        print(f"Error in handle_client for '{nickname}': {e}")
    finally:
        remove_client(client_socket, reason="disconnected") 

# --- Main Server Loop: Accept New Connections ---
server_running = True # Flag to control server's main loop
def receive_connections():
    global server_running, initial_admin_assigned
    while server_running:
        try:
            conn, addr = server.accept() 
            client_ip_addr = addr[0]
            print(f"Attempting connection from {str(addr)}")

            # --- Check for banned IP ---
            if client_ip_addr in banned_users.values(): # Check against live banned IPs
                send_message(conn, f"{ERROR_COLOR}You are banned from this server by IP address.{COLOR_RESET}")
                conn.close()
                print(f"Connection from banned IP {addr} rejected.")
                continue
            
            # --- Load/Get User Profile ---
            profile = get_user_profile(client_ip_addr)
            
            # --- Check for banned status in profile (if implemented) ---
            if profile.get('banned', False):
                send_message(conn, f"{ERROR_COLOR}You are banned from this server. Your profile is marked as banned.{COLOR_RESET}")
                conn.close()
                print(f"Connection from {addr} rejected: Profile is banned.")
                continue

            # --- Receive nickname (plain text, with timeout) ---
            # Client sends nickname. We will try to match it with profile or update profile.
            conn.settimeout(10) 
            try:
                nickname_bytes = conn.recv(BUFFER_SIZE)
                if not nickname_bytes: 
                    conn.close()
                    print(f"Client from {addr} disconnected before sending nickname.")
                    continue
                
                requested_nickname = nickname_bytes.decode('utf-8').strip()

            except socket.timeout:
                print(f"Client from {addr} timed out sending nickname.")
                conn.close()
                continue
            except Exception as e:
                print(f"Error receiving nickname from {addr}: {e}")
                conn.close()
                continue
            finally:
                conn.settimeout(None) 

            # --- Validate requested nickname ---
            if requested_nickname in nicknames.values():
                send_message(conn, f"{ERROR_COLOR}Nickname already taken! Please choose another.{COLOR_RESET}")
                conn.close()
                print(f"Connection from {addr} rejected: Nickname '{requested_nickname}' already exists.")
                continue
            
            # Update nickname in profile (if different from saved or new)
            if requested_nickname != profile['nickname']:
                profile['nickname'] = requested_nickname
                save_user_profiles() # Save updated nickname to profile

            # --- Admin Assignment & Persistence ---
            is_client_admin = profile.get('is_admin', False) # Get admin status from profile

            if client_ip_addr == INITIAL_ADMIN_IP and not initial_admin_assigned and not is_client_admin:
                profile['is_admin'] = True # Mark profile as admin
                save_user_profiles()
                initial_admin_assigned = True
                is_client_admin = True # Update live status
                send_message(conn, f"{SUCCESS_COLOR}Congratulations, you are the initial admin (from {INITIAL_ADMIN_IP})!{COLOR_RESET}")
                print(f"'{requested_nickname}' ({addr}) has been assigned as the initial admin.")
                broadcast(f"{SERVER_ANNOUNCE_COLOR}[SERVER]: {requested_nickname} has joined as the initial administrator!{COLOR_RESET}")
            elif is_client_admin:
                send_message(conn, f"{SERVER_INFO_COLOR}Welcome back, administrator!{COLOR_RESET}")
            
            # Add client to active lists (live session data)
            clients.append(conn)
            nicknames[conn] = requested_nickname
            ip_addresses[conn] = addr 
            user_colors[conn] = profile['color'] # Load color from profile
            user_statuses[conn] = "online" 

            if is_client_admin: # If they are an admin, add to live admin set
                dynamic_admin_nicknames.add(requested_nickname)

            print(f"Client '{requested_nickname}' ({addr}) connected.")
            
            # --- Send Initial Profile Data to Client ---
            # Format: YOUR_PROFILE_DATA|nickname|color|todos_json_string|is_admin
            profile_data_str = json.dumps({
                'nickname': requested_nickname,
                'color': profile['color'],
                'todos': profile['todos'],
                'is_admin': is_client_admin
            })
            send_message(conn, f"YOUR_PROFILE_DATA|{profile_data_str}")

            # Send connection and welcome messages
            send_message(conn, f"{SERVER_INFO_COLOR}Connected to the server!\n{COLOR_RESET}")
            send_message(conn, f"{SERVER_INFO_COLOR}[SERVER MOTD]: {SERVER_MOTD}{COLOR_RESET}")
            
            # Send chat history
            if message_history:
                send_message(conn, f"{SERVER_INFO_COLOR}\n--- Recent Chat History ---{COLOR_RESET}")
                for hist_msg_str in message_history:
                    send_message(conn, hist_msg_str)
                send_message(conn, f"{SERVER_INFO_COLOR}--- End of History ---\n{COLOR_RESET}")
            else:
                send_message(conn, f"{SERVER_INFO_COLOR}No chat history available yet.\n{COLOR_RESET}")
            
            # Send usage instructions (brief, /help for full list)
            send_message(conn, f"{SERVER_INFO_COLOR}Type /help for a list of commands.{COLOR_RESET}")
            send_message(conn, f"{SERVER_INFO_COLOR}Use /color <color> to set your nickname color.\n{COLOR_RESET}")
            send_message(conn, f"{SERVER_INFO_COLOR}Try sending some emojis! (Requires UTF-8 compatible terminal)\n{COLOR_RESET}")
            send_message(conn, f"{SERVER_INFO_COLOR}Your To-Do list is loaded and managed by the server. Use /todo help for commands.{COLOR_RESET}")

            # Announce new user to others 
            broadcast(f"{SERVER_INFO_COLOR}[SERVER]: {requested_nickname} has joined the chat.{COLOR_RESET}")

            # Start a new thread to handle this client's communication
            thread = threading.Thread(target=handle_client, args=(conn,))
            thread.daemon = True 
            thread.start()

        except socket.timeout:
            continue
        except Exception as e:
            if not server_running: 
                break
            print(f"Error in receive_connections: {e}")
            break 

# --- Main Server Execution ---
print("Server is starting...")
load_user_profiles() # Load profiles on startup
receive_connections()

# --- Server Shutdown Logic ---
print("Server is gracefully shutting down.")
save_user_profiles() # Save profiles on shutdown
# Close all client sockets
for client_socket in list(clients): 
    try:
        send_message(client_socket, f"{SERVER_ANNOUNCE_COLOR}[SERVER]: Server is shutting down now!{COLOR_RESET}")
        client_socket.close()
    except Exception as e:
        print(f"Error closing client socket during shutdown: {e}")
server.close() # Close the main server socket
sys.exit(0)